/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/maquette/dist/maquette.umd.js":
/*!****************************************************!*\
  !*** ./node_modules/maquette/dist/maquette.umd.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function (global, factory) {\n     true ? factory(exports) :\n    0;\n})(this, (function (exports) { 'use strict';\n\n    var NAMESPACE_W3 = \"http://www.w3.org/\";\n    var NAMESPACE_SVG = \"\".concat(NAMESPACE_W3, \"2000/svg\");\n    var NAMESPACE_XLINK = \"\".concat(NAMESPACE_W3, \"1999/xlink\");\n    var emptyArray = [];\n    var extend = function (base, overrides) {\n        var result = {};\n        Object.keys(base).forEach(function (key) {\n            result[key] = base[key];\n        });\n        if (overrides) {\n            Object.keys(overrides).forEach(function (key) {\n                result[key] = overrides[key];\n            });\n        }\n        return result;\n    };\n    var same = function (vnode1, vnode2) {\n        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n            return false;\n        }\n        if (vnode1.properties && vnode2.properties) {\n            if (vnode1.properties.key !== vnode2.properties.key) {\n                return false;\n            }\n            return vnode1.properties.bind === vnode2.properties.bind;\n        }\n        return !vnode1.properties && !vnode2.properties;\n    };\n    var checkStyleValue = function (styleValue) {\n        if (typeof styleValue !== \"string\") {\n            throw new Error(\"Style values must be strings\");\n        }\n    };\n    var findIndexOfChild = function (children, sameAs, start) {\n        if (sameAs.vnodeSelector !== \"\") {\n            // Never scan for text-nodes\n            for (var i = start; i < children.length; i++) {\n                if (same(children[i], sameAs)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n        var childNode = childNodes[indexToCheck];\n        if (childNode.vnodeSelector === \"\") {\n            return; // Text nodes need not be distinguishable\n        }\n        var properties = childNode.properties;\n        var key = properties\n            ? properties.key === undefined\n                ? properties.bind\n                : properties.key\n            : undefined;\n        if (!key) {\n            // A key is just assumed to be unique\n            for (var i = 0; i < childNodes.length; i++) {\n                if (i !== indexToCheck) {\n                    var node = childNodes[i];\n                    if (same(node, childNode)) {\n                        throw {\n                            error: new Error(\"\".concat(parentVNode.vnodeSelector, \" had a \").concat(childNode.vnodeSelector, \" child \").concat(operation === \"added\" ? operation : \"removed\", \", but there is now more than one. You must add unique key properties to make them distinguishable.\")),\n                            parentNode: parentVNode,\n                            childNode: childNode,\n                        };\n                    }\n                }\n            }\n        }\n    };\n    var nodeAdded = function (vNode) {\n        if (vNode.properties) {\n            var enterAnimation = vNode.properties.enterAnimation;\n            if (enterAnimation) {\n                enterAnimation(vNode.domNode, vNode.properties);\n            }\n        }\n    };\n    var removedNodes = [];\n    var requestedIdleCallback = false;\n    var visitRemovedNode = function (node) {\n        (node.children || []).forEach(visitRemovedNode);\n        if (node.properties && node.properties.afterRemoved) {\n            node.properties.afterRemoved.apply(node.properties.bind || node.properties, [\n                node.domNode,\n            ]);\n        }\n    };\n    var processPendingNodeRemovals = function () {\n        requestedIdleCallback = false;\n        removedNodes.forEach(visitRemovedNode);\n        removedNodes.length = 0;\n    };\n    var scheduleNodeRemoval = function (vNode) {\n        removedNodes.push(vNode);\n        if (!requestedIdleCallback) {\n            requestedIdleCallback = true;\n            if (typeof window !== \"undefined\" && \"requestIdleCallback\" in window) {\n                window.requestIdleCallback(processPendingNodeRemovals, { timeout: 16 });\n            }\n            else {\n                setTimeout(processPendingNodeRemovals, 16);\n            }\n        }\n    };\n    var nodeToRemove = function (vNode) {\n        var domNode = vNode.domNode;\n        if (vNode.properties) {\n            var exitAnimation = vNode.properties.exitAnimation;\n            if (exitAnimation) {\n                domNode.style.pointerEvents = \"none\";\n                var removeDomNode = function () {\n                    if (domNode.parentNode) {\n                        domNode.parentNode.removeChild(domNode);\n                        scheduleNodeRemoval(vNode);\n                    }\n                };\n                exitAnimation(domNode, removeDomNode, vNode.properties);\n                return;\n            }\n        }\n        if (domNode.parentNode) {\n            domNode.parentNode.removeChild(domNode);\n            scheduleNodeRemoval(vNode);\n        }\n    };\n    var setProperties = function (domNode, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        var _loop_1 = function (i) {\n            var propName = propNames[i];\n            var propValue = properties[propName];\n            if (propName === \"className\") {\n                throw new Error('Property \"className\" is not supported, use \"class\".');\n            }\n            else if (propName === \"class\") {\n                toggleClasses(domNode, propValue, true);\n            }\n            else if (propName === \"classes\") {\n                // object with string keys and boolean values\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    if (propValue[className]) {\n                        domNode.classList.add(className);\n                    }\n                }\n            }\n            else if (propName === \"styles\") {\n                // object with string keys and string (!) values\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var styleValue = propValue[styleName];\n                    if (styleValue) {\n                        checkStyleValue(styleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\n                    }\n                }\n            }\n            else if (propName === \"on\" && propValue) {\n                // object with string keys and function values\n                for (var _i = 0, _a = Object.entries(properties.on); _i < _a.length; _i++) {\n                    var _b = _a[_i], key = _b[0], handler = _b[1];\n                    var listener = typeof handler === \"function\" ? handler : handler.listener;\n                    if (eventHandlerInterceptor) {\n                        listener = eventHandlerInterceptor(key, listener, domNode, properties);\n                    }\n                    if (listener) {\n                        domNode.addEventListener(key, listener, typeof handler === \"function\" ? undefined : handler.options);\n                    }\n                }\n            }\n            else if (propName !== \"key\" && propValue !== null && propValue !== undefined) {\n                var type = typeof propValue;\n                if (type === \"function\") {\n                    if (propName.lastIndexOf(\"on\", 0) === 0) {\n                        // lastIndexOf(,0)===0 -> startsWith\n                        if (eventHandlerInterceptor) {\n                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties); // intercept eventhandlers\n                        }\n                        if (propName === \"oninput\") {\n                            (function () {\n                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\n                                var oldPropValue = propValue;\n                                propValue = function (evt) {\n                                    oldPropValue.apply(this, [evt]);\n                                    evt.target[\"oninput-value\"] = evt.target.value; // may be HTMLTextAreaElement as well\n                                };\n                            })();\n                        }\n                    }\n                    domNode[propName] = propValue;\n                }\n                else if (projectionOptions.namespace === NAMESPACE_SVG) {\n                    if (propName === \"href\") {\n                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                    }\n                    else {\n                        // all SVG attributes are read-only in DOM, so...\n                        domNode.setAttribute(propName, propValue);\n                    }\n                }\n                else if (type === \"string\" && propName !== \"value\" && propName !== \"innerHTML\") {\n                    domNode.setAttribute(propName, propValue);\n                }\n                else {\n                    domNode[propName] = propValue;\n                }\n            }\n        };\n        for (var i = 0; i < propCount; i++) {\n            _loop_1(i);\n        }\n    };\n    var addChildren = function (domNode, children, projectionOptions) {\n        if (!children) {\n            return;\n        }\n        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n            var child = children_1[_i];\n            createDom(child, domNode, undefined, projectionOptions);\n        }\n    };\n    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n        addChildren(domNode, vnode.children, projectionOptions); // children before properties, needed for value property of <select>.\n        if (vnode.text) {\n            domNode.textContent = vnode.text;\n        }\n        setProperties(domNode, vnode.properties, projectionOptions);\n        if (vnode.properties && vnode.properties.afterCreate) {\n            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [\n                domNode,\n                projectionOptions,\n                vnode.vnodeSelector,\n                vnode.properties,\n                vnode.children,\n            ]);\n        }\n    };\n    var createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n        var _a;\n        var domNode;\n        var start = 0;\n        var vnodeSelector = vnode.vnodeSelector;\n        var doc = parentNode.ownerDocument;\n        if (vnodeSelector === \"\") {\n            if (vnode.domNode) {\n                vnode.domNode.nodeValue = vnode.text;\n            }\n            else {\n                domNode = vnode.domNode = doc.createTextNode(vnode.text);\n                if (insertBefore !== undefined) {\n                    parentNode.insertBefore(domNode, insertBefore);\n                }\n                else {\n                    parentNode.appendChild(domNode);\n                }\n            }\n        }\n        else {\n            for (var i = 0; i <= vnodeSelector.length; ++i) {\n                var c = vnodeSelector.charAt(i);\n                if (i === vnodeSelector.length || c === \".\" || c === \"#\") {\n                    var type = vnodeSelector.charAt(start - 1);\n                    var found = vnodeSelector.slice(start, i);\n                    if (type === \".\") {\n                        domNode.classList.add(found);\n                    }\n                    else if (type === \"#\") {\n                        domNode.id = found;\n                    }\n                    else {\n                        if (found === \"svg\") {\n                            projectionOptions = extend(projectionOptions, {\n                                namespace: NAMESPACE_SVG,\n                            });\n                        }\n                        if (projectionOptions.namespace !== undefined) {\n                            domNode = vnode.domNode = doc.createElementNS(projectionOptions.namespace, found);\n                        }\n                        else {\n                            domNode = vnode.domNode =\n                                vnode.domNode ||\n                                    (((_a = vnode.properties) === null || _a === void 0 ? void 0 : _a.is)\n                                        ? doc.createElement(found, { is: vnode.properties.is })\n                                        : doc.createElement(found));\n                            if (found === \"input\" && vnode.properties && vnode.properties.type !== undefined) {\n                                // IE8 and older don't support setting input type after the DOM Node has been added to the document\n                                domNode.setAttribute(\"type\", vnode.properties.type);\n                            }\n                        }\n                        if (insertBefore !== undefined) {\n                            parentNode.insertBefore(domNode, insertBefore);\n                        }\n                        else if (domNode.parentNode !== parentNode) {\n                            parentNode.appendChild(domNode);\n                        }\n                    }\n                    start = i + 1;\n                }\n            }\n            initPropertiesAndChildren(domNode, vnode, projectionOptions);\n        }\n    };\n    var updateDom;\n    /**\n     * Adds or removes classes from an Element\n     * @param domNode the element\n     * @param classes a string separated list of classes\n     * @param on true means add classes, false means remove\n     */\n    var toggleClasses = function (domNode, classes, on) {\n        if (!classes) {\n            return;\n        }\n        classes.split(\" \").forEach(function (classToToggle) {\n            if (classToToggle) {\n                domNode.classList.toggle(classToToggle, on);\n            }\n        });\n    };\n    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var propertiesUpdated = false;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            // assuming that properties will be nullified instead of missing is by design\n            var propValue = properties[propName];\n            var previousValue = previousProperties[propName];\n            if (propName === \"class\") {\n                if (previousValue !== propValue) {\n                    toggleClasses(domNode, previousValue, false);\n                    toggleClasses(domNode, propValue, true);\n                }\n            }\n            else if (propName === \"classes\") {\n                var classList = domNode.classList;\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    var on = !!propValue[className];\n                    var previousOn = !!previousValue[className];\n                    if (on === previousOn) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (on) {\n                        classList.add(className);\n                    }\n                    else {\n                        classList.remove(className);\n                    }\n                }\n            }\n            else if (propName === \"styles\") {\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var newStyleValue = propValue[styleName];\n                    var oldStyleValue = previousValue[styleName];\n                    if (newStyleValue === oldStyleValue) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (newStyleValue) {\n                        checkStyleValue(newStyleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n                    }\n                    else {\n                        projectionOptions.styleApplyer(domNode, styleName, \"\");\n                    }\n                }\n            }\n            else {\n                if (!propValue && typeof previousValue === \"string\") {\n                    propValue = \"\";\n                }\n                if (propName === \"value\") {\n                    // value can be manipulated by the user directly and using event.preventDefault() is not an option\n                    var domValue = domNode[propName];\n                    if (domValue !== propValue && // The 'value' in the DOM tree !== newValue\n                        (domNode[\"oninput-value\"]\n                            ? domValue === domNode[\"oninput-value\"] // If the last reported value to 'oninput' does not match domValue, do nothing and wait for oninput\n                            : propValue !== previousValue) // Only update the value if the vdom changed\n                    ) {\n                        // The edge cases are described in the tests\n                        domNode[propName] = propValue; // Reset the value, even if the virtual DOM did not change\n                        domNode[\"oninput-value\"] = undefined;\n                    } // else do not update the domNode, otherwise the cursor position would be changed\n                    if (propValue !== previousValue) {\n                        propertiesUpdated = true;\n                    }\n                }\n                else if (propValue !== previousValue) {\n                    var type = typeof propValue;\n                    if (type !== \"function\" || !projectionOptions.eventHandlerInterceptor) {\n                        // Function updates are expected to be handled by the EventHandlerInterceptor\n                        if (projectionOptions.namespace === NAMESPACE_SVG) {\n                            if (propName === \"href\") {\n                                domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                            }\n                            else {\n                                // all SVG attributes are read-only in DOM, so...\n                                domNode.setAttribute(propName, propValue);\n                            }\n                        }\n                        else if (type === \"string\" && propName !== \"innerHTML\") {\n                            if (propName === \"role\" && propValue === \"\") {\n                                domNode.removeAttribute(propName);\n                            }\n                            else {\n                                domNode.setAttribute(propName, propValue);\n                            }\n                        }\n                        else if (domNode[propName] !== propValue) {\n                            // Comparison is here for side-effects in Edge with scrollLeft and scrollTop\n                            domNode[propName] = propValue;\n                        }\n                        propertiesUpdated = true;\n                    }\n                }\n            }\n        }\n        return propertiesUpdated;\n    };\n    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n        if (oldChildren === newChildren) {\n            return false;\n        }\n        oldChildren = oldChildren || emptyArray;\n        newChildren = newChildren || emptyArray;\n        var oldChildrenLength = oldChildren.length;\n        var newChildrenLength = newChildren.length;\n        var oldIndex = 0;\n        var newIndex = 0;\n        var i;\n        var textUpdated = false;\n        while (newIndex < newChildrenLength) {\n            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;\n            var newChild = newChildren[newIndex];\n            if (oldChild !== undefined && same(oldChild, newChild)) {\n                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n                oldIndex++;\n            }\n            else {\n                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n                if (findOldIndex >= 0) {\n                    // Remove preceding missing children\n                    for (i = oldIndex; i < findOldIndex; i++) {\n                        nodeToRemove(oldChildren[i]);\n                        checkDistinguishable(oldChildren, i, vnode, \"removed\");\n                    }\n                    textUpdated =\n                        updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n                    oldIndex = findOldIndex + 1;\n                }\n                else {\n                    // New child\n                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n                    nodeAdded(newChild);\n                    checkDistinguishable(newChildren, newIndex, vnode, \"added\");\n                }\n            }\n            newIndex++;\n        }\n        if (oldChildrenLength > oldIndex) {\n            // Remove child fragments\n            for (i = oldIndex; i < oldChildrenLength; i++) {\n                nodeToRemove(oldChildren[i]);\n                checkDistinguishable(oldChildren, i, vnode, \"removed\");\n            }\n        }\n        return textUpdated;\n    };\n    updateDom = function (previous, vnode, projectionOptions) {\n        var domNode = previous.domNode;\n        var textUpdated = false;\n        if (previous === vnode) {\n            return false; // By contract, VNode objects may not be modified anymore after passing them to maquette\n        }\n        var updated = false;\n        if (vnode.vnodeSelector === \"\") {\n            if (vnode.text !== previous.text) {\n                var newTextNode = domNode.ownerDocument.createTextNode(vnode.text);\n                domNode.parentNode.replaceChild(newTextNode, domNode);\n                vnode.domNode = newTextNode;\n                textUpdated = true;\n                return textUpdated;\n            }\n            vnode.domNode = domNode;\n        }\n        else {\n            if (vnode.vnodeSelector.lastIndexOf(\"svg\", 0) === 0) {\n                // lastIndexOf(needle,0)===0 means StartsWith\n                projectionOptions = extend(projectionOptions, {\n                    namespace: NAMESPACE_SVG,\n                });\n            }\n            if (previous.text !== vnode.text) {\n                updated = true;\n                if (vnode.text === undefined) {\n                    domNode.removeChild(domNode.firstChild); // the only textnode presumably\n                }\n                else {\n                    domNode.textContent = vnode.text;\n                }\n            }\n            vnode.domNode = domNode;\n            updated =\n                updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) ||\n                    updated;\n            updated =\n                updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) ||\n                    updated;\n            if (vnode.properties && vnode.properties.afterUpdate) {\n                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [\n                    domNode,\n                    projectionOptions,\n                    vnode.vnodeSelector,\n                    vnode.properties,\n                    vnode.children,\n                ]);\n            }\n        }\n        if (updated && vnode.properties && vnode.properties.updateAnimation) {\n            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n        }\n        return textUpdated;\n    };\n    var createProjection = function (vnode, projectionOptions) {\n        return {\n            getLastRender: function () { return vnode; },\n            update: function (updatedVnode) {\n                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n                    throw new Error(\"The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)\");\n                }\n                var previousVNode = vnode;\n                vnode = updatedVnode;\n                updateDom(previousVNode, updatedVnode, projectionOptions);\n            },\n            domNode: vnode.domNode,\n        };\n    };\n\n    var DEFAULT_PROJECTION_OPTIONS = {\n        namespace: undefined,\n        performanceLogger: function () { return undefined; },\n        eventHandlerInterceptor: undefined,\n        styleApplyer: function (domNode, styleName, value) {\n            if (styleName.charAt(0) === \"-\") {\n                // CSS variables must be set using setProperty\n                domNode.style.setProperty(styleName, value);\n            }\n            else {\n                // properties like 'backgroundColor' must be set as a js-property\n                domNode.style[styleName] = value;\n            }\n        },\n    };\n    var applyDefaultProjectionOptions = function (projectorOptions) {\n        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\n    };\n    var dom = {\n        /**\n         * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n         * its [[Projection.domNode|domNode]] property.\n         * This is a low-level method. Users will typically use a [[Projector]] instead.\n         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n         * objects may only be rendered once.\n         * @param projectionOptions - Options to be used to create and update the projection.\n         * @returns The [[Projection]] which also contains the DOM Node that was created.\n         */\n        create: function (vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, document.createElement(\"div\"), undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n         * Appends a new child node to the DOM which is generated from a [[VNode]].\n         * This is a low-level method. Users will typically use a [[Projector]] instead.\n         * @param parentNode - The parent node for the new child node.\n         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n         * objects may only be rendered once.\n         * @param projectionOptions - Options to be used to create and update the [[Projection]].\n         * @returns The [[Projection]] that was created.\n         */\n        append: function (parentNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, parentNode, undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n         * Inserts a new DOM node which is generated from a [[VNode]].\n         * This is a low-level method. Users wil typically use a [[Projector]] instead.\n         * @param beforeNode - The node that the DOM Node is inserted before.\n         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n         * NOTE: [[VNode]] objects may only be rendered once.\n         * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n         * @returns The [[Projection]] that was created.\n         */\n        insertBefore: function (beforeNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n         * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n         * This means that the virtual DOM and the real DOM will have one overlapping element.\n         * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n         * This is a low-level method. Users wil typically use a [[Projector]] instead.\n         * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and child nodes are preserved.\n         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n         * may only be rendered once.\n         * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n         * @returns The [[Projection]] that was created.\n         */\n        merge: function (element, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            vnode.domNode = element;\n            initPropertiesAndChildren(element, vnode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n         * Replaces an existing DOM node with a node generated from a [[VNode]].\n         * This is a low-level method. Users will typically use a [[Projector]] instead.\n         * @param element - The node for the [[VNode]] to replace.\n         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n         * objects may only be rendered once.\n         * @param projectionOptions - Options to be used to create and update the [[Projection]].\n         * @returns The [[Projection]] that was created.\n         */\n        replace: function (element, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, element.parentNode, element, projectionOptions);\n            element.parentNode.removeChild(element);\n            return createProjection(vnode, projectionOptions);\n        },\n    };\n\n    var toTextVNode = function (data) {\n        return {\n            vnodeSelector: \"\",\n            properties: undefined,\n            children: undefined,\n            text: data.toString(),\n            domNode: null,\n        };\n    };\n    var appendChildren = function (parentSelector, insertions, main) {\n        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {\n            var item = insertions[i];\n            if (Array.isArray(item)) {\n                appendChildren(parentSelector, item, main);\n            }\n            else {\n                if (item !== null && item !== undefined && item !== false) {\n                    if (typeof item === \"string\") {\n                        item = toTextVNode(item);\n                    }\n                    main.push(item);\n                }\n            }\n        }\n    };\n    function h(selector, properties, children) {\n        if (Array.isArray(properties)) {\n            children = properties;\n            properties = undefined;\n        }\n        else if ((properties && (typeof properties === \"string\" || properties.vnodeSelector)) ||\n            (children && (typeof children === \"string\" || children.vnodeSelector))) {\n            throw new Error(\"h called with invalid arguments\");\n        }\n        var text;\n        var flattenedChildren;\n        // Recognize a common special case where there is only a single text node\n        if (children && children.length === 1 && typeof children[0] === \"string\") {\n            text = children[0];\n        }\n        else if (children) {\n            flattenedChildren = [];\n            appendChildren(selector, children, flattenedChildren);\n            if (flattenedChildren.length === 0) {\n                flattenedChildren = undefined;\n            }\n        }\n        return {\n            vnodeSelector: selector,\n            properties: properties,\n            children: flattenedChildren,\n            text: text === \"\" ? undefined : text,\n            domNode: null,\n        };\n    }\n\n    var createParentNodePath = function (node, rootNode) {\n        var parentNodePath = [];\n        while (node && node !== rootNode) {\n            parentNodePath.push(node);\n            node = node.parentNode;\n        }\n        return parentNodePath;\n    };\n    var find;\n    if (Array.prototype.find) {\n        find = function (items, predicate) { return items.find(predicate); };\n    }\n    else {\n        find = function (items, predicate) { return items.filter(predicate)[0]; };\n    }\n    var findVNodeByParentNodePath = function (vnode, parentNodePath) {\n        var result = vnode;\n        parentNodePath.forEach(function (node) {\n            result =\n                result && result.children\n                    ? find(result.children, function (child) { return child.domNode === node; })\n                    : undefined;\n        });\n        return result;\n    };\n    var createEventHandlerInterceptor = function (projector, getProjection, performanceLogger) {\n        return function (propertyName, eventHandler, domNode, properties) { return modifiedEventHandler; };\n        function modifiedEventHandler(evt) {\n            var _a, _b;\n            performanceLogger(\"domEvent\", evt);\n            var projection = getProjection();\n            var parentNodePath = createParentNodePath(evt.currentTarget, projection.domNode);\n            parentNodePath.reverse();\n            var matchingVNode = findVNodeByParentNodePath(projection.getLastRender(), parentNodePath);\n            projector.scheduleRender();\n            var result;\n            if (matchingVNode) {\n                /* eslint-disable prefer-rest-params */\n                var listener = (_b = (_a = matchingVNode.properties[\"on\".concat(evt.type)]) !== null && _a !== void 0 ? _a : matchingVNode.properties.on[evt.type].listener) !== null && _b !== void 0 ? _b : matchingVNode.properties.on[evt.type];\n                result = listener.apply(matchingVNode.properties.bind || this, arguments);\n                /* eslint-enable prefer-rest-params */\n            }\n            performanceLogger(\"domEventProcessed\", evt);\n            return result;\n        }\n    };\n    /**\n     * Creates a [[Projector]] instance using the provided projectionOptions.\n     *\n     * For more information, see [[Projector]].\n     *\n     * @param projectorOptions   Options that influence how the DOM is rendered and updated.\n     */\n    var createProjector = function (projectorOptions) {\n        var projector;\n        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n        var performanceLogger = projectionOptions.performanceLogger;\n        var renderCompleted = true;\n        var scheduled;\n        var stopped = false;\n        var projections = [];\n        var renderFunctions = []; // matches the projections array\n        var addProjection = function (\n        /* one of: dom.append, dom.insertBefore, dom.replace, dom.merge */\n        domFunction, \n        /* the parameter of the domFunction */\n        node, renderFunction) {\n            var projection;\n            var getProjection = function () { return projection; };\n            projectionOptions.eventHandlerInterceptor = createEventHandlerInterceptor(projector, getProjection, performanceLogger);\n            projection = domFunction(node, renderFunction(), projectionOptions);\n            projections.push(projection);\n            renderFunctions.push(renderFunction);\n        };\n        var doRender = function () {\n            scheduled = undefined;\n            if (!renderCompleted) {\n                return; // The last render threw an error, it should have been logged in the browser console.\n            }\n            renderCompleted = false;\n            performanceLogger(\"renderStart\", undefined);\n            for (var i = 0; i < projections.length; i++) {\n                var updatedVnode = renderFunctions[i]();\n                performanceLogger(\"rendered\", undefined);\n                projections[i].update(updatedVnode);\n                performanceLogger(\"patched\", undefined);\n            }\n            performanceLogger(\"renderDone\", undefined);\n            renderCompleted = true;\n        };\n        projector = {\n            renderNow: doRender,\n            scheduleRender: function () {\n                if (!scheduled && !stopped) {\n                    scheduled = requestAnimationFrame(doRender);\n                }\n            },\n            stop: function () {\n                if (scheduled) {\n                    cancelAnimationFrame(scheduled);\n                    scheduled = undefined;\n                }\n                stopped = true;\n            },\n            resume: function () {\n                stopped = false;\n                renderCompleted = true;\n                projector.scheduleRender();\n            },\n            append: function (parentNode, renderFunction) {\n                addProjection(dom.append, parentNode, renderFunction);\n            },\n            insertBefore: function (beforeNode, renderFunction) {\n                addProjection(dom.insertBefore, beforeNode, renderFunction);\n            },\n            merge: function (domNode, renderFunction) {\n                addProjection(dom.merge, domNode, renderFunction);\n            },\n            replace: function (domNode, renderFunction) {\n                addProjection(dom.replace, domNode, renderFunction);\n            },\n            detach: function (renderFunction) {\n                for (var i = 0; i < renderFunctions.length; i++) {\n                    if (renderFunctions[i] === renderFunction) {\n                        renderFunctions.splice(i, 1);\n                        return projections.splice(i, 1)[0];\n                    }\n                }\n                throw new Error(\"renderFunction was not found\");\n            },\n        };\n        return projector;\n    };\n\n    /**\n     * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n     * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n     * For more information, see [[CalculationCache]].\n     *\n     * @param <Result> The type of the value that is cached.\n     */\n    var createCache = function () {\n        var cachedInputs;\n        var cachedOutcome;\n        return {\n            invalidate: function () {\n                cachedOutcome = undefined;\n                cachedInputs = undefined;\n            },\n            result: function (inputs, calculation) {\n                if (cachedInputs) {\n                    for (var i = 0; i < inputs.length; i++) {\n                        if (cachedInputs[i] !== inputs[i]) {\n                            cachedOutcome = undefined;\n                        }\n                    }\n                }\n                if (!cachedOutcome) {\n                    cachedOutcome = calculation();\n                    cachedInputs = inputs;\n                }\n                return cachedOutcome;\n            },\n        };\n    };\n\n    /**\n     * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n     * See {@link http://maquettejs.org/docs/arrays.html Working with arrays}.\n     *\n     * @param <Source>       The type of source items. A database-record for instance.\n     * @param <Target>       The type of target items. A [[MaquetteComponent]] for instance.\n     * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n     * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n     *                       to the `callback` argument in `Array.map(callback)`.\n     * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n     */\n    var createMapping = function (getSourceKey, createResult, updateResult) {\n        var keys = [];\n        var results = [];\n        return {\n            results: results,\n            map: function (newSources) {\n                var newKeys = newSources.map(getSourceKey);\n                var oldTargets = results.slice();\n                var oldIndex = 0;\n                for (var i = 0; i < newSources.length; i++) {\n                    var source = newSources[i];\n                    var sourceKey = newKeys[i];\n                    if (sourceKey === keys[oldIndex]) {\n                        results[i] = oldTargets[oldIndex];\n                        updateResult(source, oldTargets[oldIndex], i);\n                        oldIndex++;\n                    }\n                    else {\n                        var found = false;\n                        for (var j = 1; j < keys.length + 1; j++) {\n                            var searchIndex = (oldIndex + j) % keys.length;\n                            if (keys[searchIndex] === sourceKey) {\n                                results[i] = oldTargets[searchIndex];\n                                updateResult(newSources[i], oldTargets[searchIndex], i);\n                                oldIndex = searchIndex + 1;\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            results[i] = createResult(source, i);\n                        }\n                    }\n                }\n                results.length = newSources.length;\n                keys = newKeys;\n            },\n        };\n    };\n\n    exports.createCache = createCache;\n    exports.createMapping = createMapping;\n    exports.createProjector = createProjector;\n    exports.dom = dom;\n    exports.h = h;\n\n}));\n\n\n//# sourceURL=webpack://web/./node_modules/maquette/dist/maquette.umd.js?");

/***/ }),

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var maquette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! maquette */ \"./node_modules/maquette/dist/maquette.umd.js\");\n/* harmony import */ var maquette__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(maquette__WEBPACK_IMPORTED_MODULE_0__);\n\n// Maquette.js setup\nvar projector = (0,maquette__WEBPACK_IMPORTED_MODULE_0__.createProjector)();\nvar render = function () {\n    return (0,maquette__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", [\n        (0,maquette__WEBPACK_IMPORTED_MODULE_0__.h)(\"h1\", [\"Nana!\"]),\n        (0,maquette__WEBPACK_IMPORTED_MODULE_0__.h)(\"p\", [\"This is a sample page for Nana, with changes!\"]),\n    ]);\n};\nprojector.append(document.body, render);\n\n\n//# sourceURL=webpack://web/./src/app.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/app.ts");
/******/ 	
/******/ })()
;